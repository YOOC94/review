# 作业 翻译https://docs.scala-lang.org/overviews/reflection/overview.html

```$xslt

Reflection is the ability of a program to inspect, and possibly even modify itself. It has a long history across object-oriented, functional, and logic programming paradigms.
 While some languages are built around reflection as a guiding principle, many languages progressively evolve their reflection abilities over time.
反射是程序检查甚至修改自身的能力。它在面向对象，功能和逻辑编程范例方面有着悠久的历史。尽管一些语言是围绕反射作为指导原则而构建的，但是许多语言会随着时间的推移逐步发展其反射能力。
```


```$xslt

Reflection involves the ability to reify (ie. make explicit) otherwise-implicit elements of a program. 
These elements can be either static program elements like classes, methods, or expressions, or dynamic elements like the current continuation or execution events such as method invocations and field accesses. 
One usually distinguishes between compile-time and runtime reflection depending on when the reflection process is performed. 
Compile-time reflection is a powerful way to develop program transformers and generators, 
while runtime reflection is typically used to adapt the language semantics or to support very late binding between software components.
反射涉及对程序中的其他隐含元素进行修饰（即，使之明确）的能力。这些元素可以是静态程序元素，
例如类，方法或表达式，也可以是动态元素，例如当前的延续或执行事件，例如方法调用和字段访问。
通常根据执行反射过程的时间来区分编译时和运行时反射。
编译时反射是开发程序转换器和生成器的有效方法，而运行时反射通常用于调整语义或支持软件组件之间的后期绑定。

```


```

Until 2.10, Scala has not had any reflection capabilities of its own.
 Instead, one could use part of the Java reflection API, namely that dealing with providing the ability to dynamically inspect classes and objects and access their members.
 However, many Scala-specific elements are unrecoverable under standalone Java reflection, which only exposes Java elements (no functions, no traits) 
and types (no existential, higher-kinded, path-dependent and abstract types).
 In addition, Java reflection is also unable to recover runtime type info of Java types that are generic at compile-time; 
a restriction that carried through to runtime reflection on generic types in Scala.

scala没有属于自己的反射能力，直到 2.10版本。在动态检查类和对象，以及访问对象的属性这方面，可以使用java的反射API。
然而，许多scala独有的元素在java的反射API中无法通过反射恢复出来，java的反射仅仅是暴露java相关的元素和类型（没有function和trait，也没有存在的，种类较多的，依赖路径的抽象类型）
此外，java的反射也无法得到运行时的java类型信息，通常这是在编译期就生成好的，这种限制导致无法在运行期拿到scala的泛型信息
```

```$xslt

In Scala 2.10, 
a new reflection library was introduced not only to address the shortcomings of Java’s runtime reflection on Scala-specific and generic types,
 but to also add a more powerful toolkit of general reflective capabilities to Scala. 
 Along with full-featured runtime reflection for Scala types and generics,
  Scala 2.10 also ships with compile-time reflection capabilities, in the form of macros, 
  as well as the ability to reify Scala expressions into abstract syntax trees.

在Scala 2.10中，引入了一个新的反射库，不仅解决了Java在特定于Scala的类型和泛型类型上的运行时反射的缺点，
而且还向Scala添加了更强大的常规反射功能的工具包。
除了针对Scala类型和泛型的全功能运行时反射外，Scala 2.10还以宏形式来拥有编译时反射功能，以及将Scala表达式化为抽象语法树的功能。

```

# Runtime Reflection 运行时反射

```$xslt
What is runtime reflection? Given a type or instance of some object at runtime, reflection is the ability to:

inspect the type of that object, including generic types,
to instantiate new objects,
or to access or invoke members of that object.
Let’s jump in and see how to do each of the above with a few examples.

在运行时给定一个类型或者对象，我们通过反射可以：
1.检查对象的类型和泛型
2.实例化一个新的对象
3.访问对象的属性或者执行对象方法
下面给几个例子
```
## Examples 例子
### INSPECTING A RUNTIME TYPE (INCLUDING GENERIC TYPES AT RUNTIME) 运行时检查类型
```$xslt
As with other JVM languages, Scala’s types are erased at compile time. 
This means that if you were to inspect the runtime type of some instance, 
that you might not have access to all type information that the Scala compiler has available at compile time.
与其他JVM语言一样，Scala的类型在编译时会被擦除。这意味着如果我们想在运行期检查一些实例，则可能无法拿到Scala编译器在编译时可用的所有类型信息。

TypeTags can be thought of as objects which carry along all type information available at compile time, to runtime. 
Though, it’s important to note that TypeTags are always generated by the compiler. 
This generation is triggered whenever an implicit parameter or context bound requiring a TypeTag is used.
 This means that, typically, one can only obtain a TypeTag using implicit parameters or context bounds.
TypeTags 可以把它看做是运行期携带了所有编译期信息的对象。不过，TypeTag始终由编译器生成，这点很重要。每当隐式参数或上下文绑定时需要使用TypeTag，都会触发TypeTags的生成。
这意味着通常情况下，只能使用隐式参数或上下文来获取TypeTag。

```
```$xslt
scala> import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.{universe=>ru}

scala> val l = List(1,2,3)
l: List[Int] = List(1, 2, 3)

scala> def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
getTypeTag: [T](obj: T)(implicit evidence$1: ru.TypeTag[T])ru.TypeTag[T]

scala> val theType = getTypeTag(l).tpe
theType: ru.Type = List[Int]
```

```$xslt
In the above, we first import scala.reflect.runtime.universe (it must always be imported in order to use TypeTags), 
and we create a List[Int] called l. 
Then, we define a method getTypeTag which has a type parameter T that has a context bound
 (as the REPL shows, this is equivalent to defining an implicit “evidence” parameter, which causes the compiler to generate a TypeTag for T).
 Finally, we invoke our method with l as its parameter, and call tpe which returns the type contained in the TypeTag. 
As we can see, we get the correct, complete type (including List’s concrete type argument), List[Int].

Once we have obtained the desired Type instance, we can inspect it, e.g.:
scala> val decls = theType.decls.take(10)
decls: Iterable[ru.Symbol] = List(constructor List, method companion, method isEmpty, method head, method tail, method ::, method :::, method reverse_:::, method mapConserve, method ++)
1.首先要导包 scala.reflect.runtime.universe(为了使用TypeTags，这个必须要导入)
2.然后我们定义了一个List[Int],变量l来接收
3.接着我们定义了一个方法getTypeTag，这个方法的参数是有上下文绑定的
4.最后我们调用这个getTypeTag方法，以l作为参数，并调用tye方法来返回TypeTag里面包含的类型信息
这样我们就能够获取到完整类型了
一旦获得所需的Type实例，就可以对其进行检查
```

## INSTANTIATING A TYPE AT RUNTIME 在运行时实例化类型

```$xslt
Types obtained through reflection can be instantiated by invoking their constructor using an appropriate “invoker” mirror (mirrors are expanded upon below).
 Let’s walk through an example using the REPL
scala> case class Person(name: String)
defined class Person

scala> val m = ru.runtimeMirror(getClass.getClassLoader)
m: scala.reflect.runtime.universe.Mirror = JavaMirror with ...

通过反射获得的Types可以通过使用适当的“invoker” mirror调用构造器来实例化（mirror在下面进行了扩展）。让我们来看一个使用REPL的示例
In the first step we obtain a mirror m which makes all classes and types available that are loaded by the current classloader, including class Person
1.第一步我们先获取到一个mirror，镜像里包含了当前类加载器加载的所有类和类型的信息，包括了Person的信息
scala> val classPerson = ru.typeOf[Person].typeSymbol.asClass
classPerson: scala.reflect.runtime.universe.ClassSymbol = class Person

scala> val cm = m.reflectClass(classPerson)
cm: scala.reflect.runtime.universe.ClassMirror = class mirror for Person (bound to null)

The second step involves obtaining a ClassMirror for class Person using the reflectClass method. The ClassMirror provides access to the constructor of class Person
scala> val ctor = ru.typeOf[Person].decl(ru.termNames.CONSTRUCTOR).asMethod
ctor: scala.reflect.runtime.universe.MethodSymbol = constructor Person
2.第二步使用reflectClass方法为类Person获取ClassMirror。 ClassMirror提供对Person类的构造函数的访问

The symbol for Persons constructor can be obtained using only the runtime universe ru by looking it up in the declarations of type Person.
scala> val ctorm = cm.reflectConstructor(ctor)
ctorm: scala.reflect.runtime.universe.MethodMirror = constructor mirror for Person.<init>(name: String): Person (bound to null)

scala> val p = ctorm("Mike")
p: Any = Person(Mike)
通过查看Person类的声明 仅适用运行时的universe ru就可以获得Person的构造器符号

```

# ACCESSING AND INVOKING MEMBERS OF RUNTIME TYPES 访问和调用运行时类型的成员

```$xslt
In general, members of runtime types are accessed using an appropriate “invoker” mirror (mirrors are expanded upon below). Let’s walk through an example using the REPL:
scala> case class Purchase(name: String, orderNumber: Int, var shipped: Boolean)
defined class Purchase

scala> val p = Purchase("Jeff Lebowski", 23819, false)
p: Purchase = Purchase(Jeff Lebowski,23819,false)

通常，我们可以通过使用适当的“invoker” mirror来访问运行时的成员的类型

In this example, we will attempt to get and set the shipped field of Purchase p, reflectively
scala> import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.{universe=>ru}

scala> val m = ru.runtimeMirror(p.getClass.getClassLoader)
m: scala.reflect.runtime.universe.Mirror = JavaMirror with ...

在这个案例中，我们试图用反射去获取和设置Purchase p 的字段 shipped
As we did in the previous example, we’ll begin by obtaining a mirror m, 
which makes all classes and types available that are loaded by the classloader that also loaded the class of p (Purchase), 
which we need in order to access member shipped
与前面的示例一样，我们首先要获取 mirror m，该mirror使所有由类加载器加载的类和类型可用，该类加载器还加载了p类，这是我们访问成员shipped所需要的

scala> val shippingTermSymb = ru.typeOf[Purchase].decl(ru.TermName("shipped")).asTerm
shippingTermSymb: scala.reflect.runtime.universe.TermSymbol = method shipped

We now look up the declaration of the shipped field, which gives us a TermSymbol (a type of Symbol).
 We’ll need to use this Symbol later to obtain a mirror that gives us access to the value of this field (for some instance).
现在，我们查找shipped字段的声明，这为我们提供了TermSymbol（一种Symbol类型）。稍后，我们将需要使用此Symbol获取一个mirror，该mirror使我们可以访问此字段的值（在某些情况下）。
scala> val im = m.reflect(p)
im: scala.reflect.runtime.universe.InstanceMirror = instance mirror for Purchase(Jeff Lebowski,23819,false)

scala> val shippingFieldMirror = im.reflectField(shippingTermSymb)
shippingFieldMirror: scala.reflect.runtime.universe.FieldMirror = field mirror for Purchase.shipped (bound to Purchase(Jeff Lebowski,23819,false))

In order to access a specific instance’s shipped member, we need a mirror for our specific instance, p’s instance mirror, im. 
Given our instance mirror, we can obtain a FieldMirror for any TermSymbol representing a field of p’s type.

为了访问特定实例的成员 shipped，我们需要为特定实例创建一个mirror，即p的实例 mirror im。给定实例mirror，我们可以为表示p类型字段的任何TermSymbol获取FieldMirror。

Now that we have a FieldMirror for our specific field, we can use methods get and set to get/set our specific instance’s shipped member.
 Let’s change the status of shipped to true
现在，我们已经为特定的字段提供了FieldMirror，我们可以使用get和set方法来get/set特定实例的shipped成员。让我们将shipped状态更改为true

scala> shippingFieldMirror.get
res7: Any = false

scala> shippingFieldMirror.set(true)

scala> shippingFieldMirror.get
res9: Any = true
```

# Runtime Classes in Java vs. Runtime Types in Scala java运行时和scala运行时
```$xslt
Those who are comfortable using Java reflection to obtain Java Class instances at runtime might have noticed that,
 in Scala, we instead obtain runtime types.
The REPL-run below shows a very simple scenario where using Java reflection on Scala classes might return surprising or incorrect results.
First, we define a base class E with an abstract type member T, and from it, we derive two subclasses, C and D
scala> class E {
     |   type T
     |   val x: Option[T] = None
     | }
defined class E

scala> class C extends E
defined class C

scala> class D extends C
defined class D
Then, we create an instance of both C and D, meanwhile making type member T concrete (in both cases, String)
scala> val c = new C { type T = String }
c: C{type T = String} = $anon$1@7113bc51

scala> val d = new D { type T = String }
d: D{type T = String} = $anon$1@46364879
那些乐于使用Java反射在运行时获取Java类实例的人可能已经注意到，在Scala中，我们改为获取运行时类型
下面的REPL运行显示了一个非常简单的场景，在Scala类上使用Java反射可能会返回令人惊讶或错误的结果。
首先，我们定义具有抽象类型成员T的基类E，然后从中派生两个子类C和D
然后，我们创建C和D的实例，同时将类型成员T具体化（在两种情况下均为String）

Now, we use methods getClass and isAssignableFrom from Java Reflection to obtain an instance of java.lang.Class representing the runtime classes of c and d, 
and then we test to see that d’s runtime class is a subclass of c’s runtime representation.
现在，我们使用Java Reflection中的getClass和isAssignableFrom方法来获取表示c和d的运行时类的java.lang.Class实例，
然后进行测试，查看d的运行时类是c的运行时表示形式的子类。
scala> c.getClass.isAssignableFrom(d.getClass)
res6: Boolean = false

Since above, we saw that D extends C, this result is a bit surprising. 
In performing this simple runtime type check, 
one would expect the result of the question “is the class of d a subclass of the class of c?” to be true. 
However, as you might’ve noticed above, when c and d are instantiated, 
the Scala compiler actually creates anonymous subclasses of C and D, respectively. 
This is due to the fact that the Scala compiler must translate Scala-specific 
(i.e., non-Java) language features into some equivalent in Java bytecode in order to be able to run on the JVM. 
Thus, the Scala compiler often creates synthetic classes (i.e. automatically-generated classes) that are used at runtime in place of user-defined classes. 
This is quite commonplace in Scala and can be observed when using Java reflection with a number of Scala features, 
e.g. closures, type members, type refinements, local classes, etc.
从上面来看，我们看到D继承自C，这个结果有点令人惊讶。
在执行这种简单的运行时类型检查时，我们可能期望：“ d的类是否是c的类的子类？”的结果是true。
但是，正如您在上面可能已经注意到的那样，当实例化c和d时，Scala编译器实际上分别创建了C和D的匿名子类。
这是由于这样的事实，Scala编译器必须将特定于Scala的（即非Java）语言功能转换为Java字节码中的某些等效功能，以便能够在JVM上运行。
因此，Scala编译器通常会创建运行时使用的合成类（即自动生成的类）来代替用户定义的类。
这在Scala中非常普遍，在将Java反射与许多Scala功能结合使用时可以观察到这种情况，例如闭包，类型成员，类型细化，局部类等。

In situations like these, we can instead use Scala reflection to obtain precise runtime types of these Scala objects. 
Scala runtime types carry along all type info from compile-time, avoiding these types mismatches between compile-time and run-time.
Below, we use define a method which uses Scala reflection to get the runtime types of its arguments, and then checks the subtyping relationship between the two.
 If its first argument’s type is a subtype of its second argument’s type, it returns true.
在这种情况下，我们可以改用Scala反射来获取这些Scala对象的精确运行时类型。 Scala运行时类型包含编译时的所有类型信息，避免了编译时和运行时之间这些类型的不匹配。
下面，我们定义了一个方法，该方法使用Scala反射来获取其参数的运行时类型，然后检查两者之间的子类型关系。如果第一个参数的类型是第二个参数的子类型，则返回true
scala> import scala.reflect.runtime.{universe => ru}
import scala.reflect.runtime.{universe=>ru}

scala> def m[T: ru.TypeTag, S: ru.TypeTag](x: T, y: S): Boolean = {
    |   val leftTag = ru.typeTag[T]
    |   val rightTag = ru.typeTag[S]
    |   leftTag.tpe <:< rightTag.tpe
    | }
m: [T, S](x: T, y: S)(implicit evidence$1: scala.reflect.runtime.universe.TypeTag[T], implicit evidence$2: scala.reflect.runtime.universe.TypeTag[S])Boolean

scala> m(d, c)
res9: Boolean = true
As we can see, we now get the expected result– d’s runtime type is indeed a subtype of c’s runtime type.
如我们所见，我们现在得到了预期的结果– d的运行时类型确实是c的运行时类型的子类型。
```

# Compile-time Reflection 编译期反射

```$xslt

Scala reflection enables a form of metaprogramming which makes it possible for programs to modify themselves at compile time.
 This compile-time reflection is realized in the form of macros, 
which provide the ability to execute methods that manipulate abstract syntax trees at compile-time.

A particularly interesting aspect of macros is that they are based on the same API used also for Scala’s runtime reflection, provided in package scala.reflect.api. 
This enables the sharing of generic code between macros and implementations that utilize runtime reflection.

Note that the macros guide focuses on macro specifics, whereas this guide focuses on the general aspects of the reflection API. 
Many concepts directly apply to macros, though, such as abstract syntax trees which are discussed in greater detail in the section on Symbols, Trees, and Types.

Scala反射实现了一种元编程形式，这使得程序可以在编译时对其进行修改。这种编译时反射是通过宏的形式实现的，这些宏提供了在编译时执行操作抽象语法树的方法的能力。
宏的一个特别有趣的方面是，它们基于Scala.reflect.api包中提供的，和Scala运行时反射用的同一套API。这样运行时反射的实现和宏之间就可以共享通用代码。
请注意，宏指南侧重于宏细节，而本指南侧重于反射API的一般方面。但是，许多概念直接适用于宏，例如抽象语法树，有关符号，树和类型的部分将对其进行详细讨论
```

# Environment
```$xslt
All reflection tasks require a proper environment to be set up. 
This environment differs based on whether the reflective task is to be done at run time or at compile time. 
The distinction between an environment to be used at run time or compile time is encapsulated in a so-called universe.
 Another important aspect of the reflective environment is the set of entities that we have reflective access to.
 This set of entities is determined by a so-called mirror.

Mirrors not only determine the set of entities that can be accessed reflectively. 
They also provide reflective operations to be performed on those entities. 
For example, in runtime reflection an invoker mirror can be used to invoke a method or constructor of a class.

所有反射任务都需要设置适当的环境。根据运行时还是在编译时完成反射任务，该环境是不同的。
在运行时或编译时使用的环境之间的区别封装在所谓的Universe中。反射环境的另一个重要方面是我们可以通过反射访问的一组实体。这组实体由所谓的镜像决定的。

Mirrors不仅决定可以反射访问的实体集。它们还提供对这些实体执行的反射操作。例如，在运行时反射中，可以使用调用程序镜像来调用类的方法或构造函数。
```


# Universes

```$xslt
Universe is the entry point to Scala reflection. 
A universe provides an interface to all the principal concepts used in reflection, such as Types, Trees, and Annotations. 
For more details, see the section of this guide on Universes, or the Universes API docs in package scala.reflect.api.

Universe是Scala反射的入口点。 Universe提供了反射中使用的所有主要概念的接口，例如类型，树和注释。详情见Universe章节或者包scala.reflect.api中的相关API文档

To use most aspects of Scala reflection, including most code examples provided in this guide, you need to make sure you import a Universe or the members of a Universe.
 Typically, to use runtime reflection, one can import all members of scala.reflect.runtime.universe, using a wildcard import:
import scala.reflect.runtime.universe._
要使用Scala反射的大多数方面，包括本指南中提供的大多数代码示例，您需要确保导入Universe或Universe的成员。
通常，在使用运行时反射时 我们可以导入scala.reflect.runtime.universe下的所有成员，例如 import scala.reflect.runtime.universe._
```

# Mirrors
```$xslt
Mirrors are a central part of Scala Reflection. All information provided by reflection is made accessible through these so-called mirrors.
 Depending on the type of information to be obtained, or the reflective action to be taken, different flavors of mirrors must be used.

For more details, see the section of this guide on Mirrors, or the Mirrors API docs in package scala.reflect.api.
Mirrors是Scala Reflection的核心部分。反射提供的所有信息都可以通过这些所谓的mirrors访问。根据要获得的信息类型或要采取的反射作用，必须使用不同类型的mirrors。
```



